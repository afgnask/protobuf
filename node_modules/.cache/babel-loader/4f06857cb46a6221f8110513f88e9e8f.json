{"ast":null,"code":"import JSBI from \"jsbi\";\nimport { bufferLeToBeHex, bufferToPrettyHex } from \"./hexUtils\";\nimport { interpretAsSignedType } from \"./varintUtils\";\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n  const result = [];\n  result.push({\n    type: \"Int\",\n    value: intValue\n  });\n\n  if (intValue !== uintValue) {\n    result.push({\n      type: \"Unsigned Int\",\n      value: uintValue\n    });\n  }\n\n  result.push({\n    type: \"Float\",\n    value: floatValue\n  });\n  return result;\n}\nexport function decodeFixed64(value) {\n  const floatValue = value.readDoubleLE(0);\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n  const result = [];\n  result.push({\n    type: \"Int\",\n    value: intValue.toString()\n  });\n  return result;\n}\nexport function decodeVarintParts(value) {\n  const result = [];\n  const intVal = JSBI.BigInt(value);\n  result.push({\n    type: \"Int\",\n    value: intVal.toString()\n  });\n  return result;\n}\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}","map":{"version":3,"sources":["/Users/afganaskarli/PycharmProjects/buf/src/protobufPartDecoder.js"],"names":["JSBI","bufferLeToBeHex","bufferToPrettyHex","interpretAsSignedType","decodeFixed32","value","floatValue","readFloatLE","intValue","readInt32LE","uintValue","readUInt32LE","result","push","type","decodeFixed64","readDoubleLE","BigInt","twoComplements","toString","decodeVarintParts","intVal","maxLong","longForComplement","greaterThan","subtract"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,MAAjB;AACA,SAASC,eAAT,EAA0BC,iBAA1B,QAAmD,YAAnD;AACA,SAASC,qBAAT,QAAsC,eAAtC;AAEA,OAAO,SAASC,aAAT,CAAuBC,KAAvB,EAA8B;AACnC,QAAMC,UAAU,GAAGD,KAAK,CAACE,WAAN,CAAkB,CAAlB,CAAnB;AACA,QAAMC,QAAQ,GAAGH,KAAK,CAACI,WAAN,CAAkB,CAAlB,CAAjB;AACA,QAAMC,SAAS,GAAGL,KAAK,CAACM,YAAN,CAAmB,CAAnB,CAAlB;AAEA,QAAMC,MAAM,GAAG,EAAf;AAEAA,EAAAA,MAAM,CAACC,IAAP,CAAY;AAAEC,IAAAA,IAAI,EAAE,KAAR;AAAeT,IAAAA,KAAK,EAAEG;AAAtB,GAAZ;;AAEA,MAAIA,QAAQ,KAAKE,SAAjB,EAA4B;AAC1BE,IAAAA,MAAM,CAACC,IAAP,CAAY;AAAEC,MAAAA,IAAI,EAAE,cAAR;AAAwBT,MAAAA,KAAK,EAAEK;AAA/B,KAAZ;AACD;;AAEDE,EAAAA,MAAM,CAACC,IAAP,CAAY;AAAEC,IAAAA,IAAI,EAAE,OAAR;AAAiBT,IAAAA,KAAK,EAAEC;AAAxB,GAAZ;AAEA,SAAOM,MAAP;AACD;AAED,OAAO,SAASG,aAAT,CAAuBV,KAAvB,EAA8B;AACnC,QAAMC,UAAU,GAAGD,KAAK,CAACW,YAAN,CAAmB,CAAnB,CAAnB;AACA,QAAMN,SAAS,GAAGV,IAAI,CAACiB,MAAL,CAAY,OAAOhB,eAAe,CAACI,KAAD,CAAlC,CAAlB;AACA,QAAMG,QAAQ,GAAGU,cAAc,CAACR,SAAD,CAA/B;AAEA,QAAME,MAAM,GAAG,EAAf;AAEAA,EAAAA,MAAM,CAACC,IAAP,CAAY;AAAEC,IAAAA,IAAI,EAAE,KAAR;AAAeT,IAAAA,KAAK,EAAEG,QAAQ,CAACW,QAAT;AAAtB,GAAZ;AAGA,SAAOP,MAAP;AACD;AAED,OAAO,SAASQ,iBAAT,CAA2Bf,KAA3B,EAAkC;AACvC,QAAMO,MAAM,GAAG,EAAf;AACA,QAAMS,MAAM,GAAGrB,IAAI,CAACiB,MAAL,CAAYZ,KAAZ,CAAf;AACAO,EAAAA,MAAM,CAACC,IAAP,CAAY;AAAEC,IAAAA,IAAI,EAAE,KAAR;AAAeT,IAAAA,KAAK,EAAEgB,MAAM,CAACF,QAAP;AAAtB,GAAZ;AAGA,SAAOP,MAAP;AACD;AAED,MAAMU,OAAO,GAAGtB,IAAI,CAACiB,MAAL,CAAY,oBAAZ,CAAhB;AACA,MAAMM,iBAAiB,GAAGvB,IAAI,CAACiB,MAAL,CAAY,qBAAZ,CAA1B;;AAEA,SAASC,cAAT,CAAwBR,SAAxB,EAAmC;AACjC,MAAIV,IAAI,CAACwB,WAAL,CAAiBd,SAAjB,EAA4BY,OAA5B,CAAJ,EAA0C;AACxC,WAAOtB,IAAI,CAACyB,QAAL,CAAcf,SAAd,EAAyBa,iBAAzB,CAAP;AACD,GAFD,MAEO;AACL,WAAOb,SAAP;AACD;AACF","sourcesContent":["import JSBI from \"jsbi\";\nimport { bufferLeToBeHex, bufferToPrettyHex } from \"./hexUtils\";\nimport { interpretAsSignedType } from \"./varintUtils\";\n\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue });\n  }\n\n  result.push({ type: \"Float\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeFixed64(value) {\n  const floatValue = value.readDoubleLE(0);\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue.toString() });\n\n\n  return result;\n}\n\nexport function decodeVarintParts(value) {\n  const result = [];\n  const intVal = JSBI.BigInt(value);\n  result.push({ type: \"Int\", value: intVal.toString() });\n\n\n  return result;\n}\n\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}