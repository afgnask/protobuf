{"ast":null,"code":"import JSBI from \"jsbi\";\nimport { bufferLeToBeHex, bufferToPrettyHex } from \"./hexUtils\";\nimport { interpretAsSignedType } from \"./varintUtils\";\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n  const result = [];\n  result.push({\n    type: \"Int\",\n    value: intValue\n  });\n\n  if (intValue !== uintValue) {\n    result.push({\n      type: \"Unsigned Int\",\n      value: uintValue\n    });\n  }\n\n  result.push({\n    type: \"Float\",\n    value: floatValue\n  });\n  return result;\n}\nexport function decodeFixed64(value) {\n  const floatValue = value.readDoubleLE(0);\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n  const result = [];\n  result.push({\n    type: \"Int\",\n    value: intValue.toString()\n  });\n\n  if (intValue !== uintValue) {\n    result.push({\n      type: \"Unsigned Int\",\n      value: uintValue.toString()\n    });\n  }\n\n  result.push({\n    type: \"Double\",\n    value: floatValue\n  });\n  return result;\n}\nexport function decodeVarintParts(value) {\n  const result = [];\n  const intVal = JSBI.BigInt(value);\n  result.push({\n    type: \"Int\",\n    value: intVal.toString()\n  });\n  const signedIntVal = interpretAsSignedType(intVal);\n\n  if (signedIntVal !== intVal) {\n    result.push({\n      type: \"Signed Int\",\n      value: signedIntVal.toString()\n    });\n  }\n\n  return result;\n}\nexport function decodeStringOrBytes(value) {\n  if (!value.length) {\n    return {\n      type: \"string|bytes\",\n      value: \"\"\n    };\n  }\n\n  const td = new TextDecoder(\"utf-8\", {\n    fatal: true\n  });\n\n  try {\n    return {\n      type: \"string\",\n      value: td.decode(value)\n    };\n  } catch (e) {\n    return {\n      type: \"bytes\",\n      value: bufferToPrettyHex(value)\n    };\n  }\n}\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}","map":{"version":3,"sources":["/Users/afganaskarli/PycharmProjects/buf/src/protobufPartDecoder.js"],"names":["JSBI","bufferLeToBeHex","bufferToPrettyHex","interpretAsSignedType","decodeFixed32","value","floatValue","readFloatLE","intValue","readInt32LE","uintValue","readUInt32LE","result","push","type","decodeFixed64","readDoubleLE","BigInt","twoComplements","toString","decodeVarintParts","intVal","signedIntVal","decodeStringOrBytes","length","td","TextDecoder","fatal","decode","e","maxLong","longForComplement","greaterThan","subtract"],"mappings":"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","sourcesContent":["import JSBI from \"jsbi\";\nimport { bufferLeToBeHex, bufferToPrettyHex } from \"./hexUtils\";\nimport { interpretAsSignedType } from \"./varintUtils\";\n\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue });\n  }\n\n  result.push({ type: \"Float\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeFixed64(value) {\n  const floatValue = value.readDoubleLE(0);\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue.toString() });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue.toString() });\n  }\n\n  result.push({ type: \"Double\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeVarintParts(value) {\n  const result = [];\n  const intVal = JSBI.BigInt(value);\n  result.push({ type: \"Int\", value: intVal.toString() });\n\n  const signedIntVal = interpretAsSignedType(intVal);\n  if (signedIntVal !== intVal) {\n    result.push({ type: \"Signed Int\", value: signedIntVal.toString() });\n  }\n  return result;\n}\n\nexport function decodeStringOrBytes(value) {\n  if (!value.length) {\n    return { type: \"string|bytes\", value: \"\" };\n  }\n  const td = new TextDecoder(\"utf-8\", { fatal: true });\n  try {\n    return { type: \"string\", value: td.decode(value) };\n  } catch (e) {\n    return { type: \"bytes\", value: bufferToPrettyHex(value) };\n  }\n}\n\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}