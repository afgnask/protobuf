{"ast":null,"code":"import JSBI from \"jsbi\";\nconst BIGINT_1 = JSBI.BigInt(1);\nconst BIGINT_2 = JSBI.BigInt(2);\nexport function interpretAsSignedType(n) {\n  // see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n  // however, this is a simpler equivalent formula\n  const isEven = JSBI.equal(JSBI.bitwiseAnd(n, JSBI.BigInt(1)), JSBI.BigInt(0));\n\n  if (isEven) {\n    return JSBI.divide(n, BIGINT_2);\n  } else {\n    return JSBI.multiply(JSBI.BigInt(-1), JSBI.divide(JSBI.add(n, BIGINT_1), BIGINT_2));\n  }\n}\nexport function decodeVarint(buffer, offset) {\n  let res = JSBI.BigInt(0);\n  let shift = 0;\n  let byte = 0;\n\n  do {\n    if (offset >= buffer.length) {\n      throw new RangeError(\"Index out of bound decoding varint\");\n    }\n\n    byte = buffer[offset++];\n    const multiplier = JSBI.exponentiate(BIGINT_2, JSBI.BigInt(shift));\n    const thisByteValue = JSBI.multiply(JSBI.BigInt(byte & 0x7f), multiplier);\n    shift += 7;\n    res = JSBI.add(res, thisByteValue);\n  } while (byte >= 0x80);\n\n  return {\n    value: res,\n    length: shift / 7\n  };\n}","map":{"version":3,"sources":["/Users/afganaskarli/PycharmProjects/buf/src/varintUtils.js"],"names":["JSBI","BIGINT_1","BigInt","BIGINT_2","interpretAsSignedType","n","isEven","equal","bitwiseAnd","divide","multiply","add","decodeVarint","buffer","offset","res","shift","byte","length","RangeError","multiplier","exponentiate","thisByteValue","value"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,MAAjB;AAEA,MAAMC,QAAQ,GAAGD,IAAI,CAACE,MAAL,CAAY,CAAZ,CAAjB;AACA,MAAMC,QAAQ,GAAGH,IAAI,CAACE,MAAL,CAAY,CAAZ,CAAjB;AAEA,OAAO,SAASE,qBAAT,CAA+BC,CAA/B,EAAkC;AACvC;AACA;AACA,QAAMC,MAAM,GAAGN,IAAI,CAACO,KAAL,CAAWP,IAAI,CAACQ,UAAL,CAAgBH,CAAhB,EAAmBL,IAAI,CAACE,MAAL,CAAY,CAAZ,CAAnB,CAAX,EAA+CF,IAAI,CAACE,MAAL,CAAY,CAAZ,CAA/C,CAAf;;AACA,MAAII,MAAJ,EAAY;AACV,WAAON,IAAI,CAACS,MAAL,CAAYJ,CAAZ,EAAeF,QAAf,CAAP;AACD,GAFD,MAEO;AACL,WAAOH,IAAI,CAACU,QAAL,CACLV,IAAI,CAACE,MAAL,CAAY,CAAC,CAAb,CADK,EAELF,IAAI,CAACS,MAAL,CAAYT,IAAI,CAACW,GAAL,CAASN,CAAT,EAAYJ,QAAZ,CAAZ,EAAmCE,QAAnC,CAFK,CAAP;AAID;AACF;AAED,OAAO,SAASS,YAAT,CAAsBC,MAAtB,EAA8BC,MAA9B,EAAsC;AAC3C,MAAIC,GAAG,GAAGf,IAAI,CAACE,MAAL,CAAY,CAAZ,CAAV;AACA,MAAIc,KAAK,GAAG,CAAZ;AACA,MAAIC,IAAI,GAAG,CAAX;;AAEA,KAAG;AACD,QAAIH,MAAM,IAAID,MAAM,CAACK,MAArB,EAA6B;AAC3B,YAAM,IAAIC,UAAJ,CAAe,oCAAf,CAAN;AACD;;AAEDF,IAAAA,IAAI,GAAGJ,MAAM,CAACC,MAAM,EAAP,CAAb;AAEA,UAAMM,UAAU,GAAGpB,IAAI,CAACqB,YAAL,CAAkBlB,QAAlB,EAA4BH,IAAI,CAACE,MAAL,CAAYc,KAAZ,CAA5B,CAAnB;AACA,UAAMM,aAAa,GAAGtB,IAAI,CAACU,QAAL,CAAcV,IAAI,CAACE,MAAL,CAAYe,IAAI,GAAG,IAAnB,CAAd,EAAwCG,UAAxC,CAAtB;AACAJ,IAAAA,KAAK,IAAI,CAAT;AACAD,IAAAA,GAAG,GAAGf,IAAI,CAACW,GAAL,CAASI,GAAT,EAAcO,aAAd,CAAN;AACD,GAXD,QAWSL,IAAI,IAAI,IAXjB;;AAaA,SAAO;AACLM,IAAAA,KAAK,EAAER,GADF;AAELG,IAAAA,MAAM,EAAEF,KAAK,GAAG;AAFX,GAAP;AAID","sourcesContent":["import JSBI from \"jsbi\";\n\nconst BIGINT_1 = JSBI.BigInt(1);\nconst BIGINT_2 = JSBI.BigInt(2);\n\nexport function interpretAsSignedType(n) {\n  // see https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wire_format_lite.h#L857-L876\n  // however, this is a simpler equivalent formula\n  const isEven = JSBI.equal(JSBI.bitwiseAnd(n, JSBI.BigInt(1)), JSBI.BigInt(0));\n  if (isEven) {\n    return JSBI.divide(n, BIGINT_2);\n  } else {\n    return JSBI.multiply(\n      JSBI.BigInt(-1),\n      JSBI.divide(JSBI.add(n, BIGINT_1), BIGINT_2)\n    );\n  }\n}\n\nexport function decodeVarint(buffer, offset) {\n  let res = JSBI.BigInt(0);\n  let shift = 0;\n  let byte = 0;\n\n  do {\n    if (offset >= buffer.length) {\n      throw new RangeError(\"Index out of bound decoding varint\");\n    }\n\n    byte = buffer[offset++];\n\n    const multiplier = JSBI.exponentiate(BIGINT_2, JSBI.BigInt(shift));\n    const thisByteValue = JSBI.multiply(JSBI.BigInt(byte & 0x7f), multiplier);\n    shift += 7;\n    res = JSBI.add(res, thisByteValue);\n  } while (byte >= 0x80);\n\n  return {\n    value: res,\n    length: shift / 7\n  };\n}\n"]},"metadata":{},"sourceType":"module"}