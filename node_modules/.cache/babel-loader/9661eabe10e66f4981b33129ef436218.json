{"ast":null,"code":"import { decodeVarint } from \"./varintUtils\";\n\nclass BufferReader {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  readVarInt() {\n    const result = decodeVarint(this.buffer, this.offset);\n    this.offset += result.length;\n    return result.value;\n  }\n\n  readBuffer(length) {\n    this.checkByte(length);\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return result;\n  } // gRPC has some additional header - remove it\n\n\n  trySkipGrpcHeader() {\n    const backupOffset = this.offset;\n\n    if (this.buffer[this.offset] === 0 && this.leftBytes() >= 5) {\n      this.offset++;\n      const length = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n\n      if (length > this.leftBytes()) {\n        // Something is wrong, revert\n        this.offset = backupOffset;\n      }\n    }\n  }\n\n  leftBytes() {\n    return this.buffer.length - this.offset;\n  }\n\n  checkByte(length) {\n    const bytesAvailable = this.leftBytes();\n\n    if (length > bytesAvailable) {\n      throw new Error(\"Not enough bytes left. Requested: \" + length + \" left: \" + bytesAvailable);\n    }\n  }\n\n  checkpoint() {\n    this.savedOffset = this.offset;\n  }\n\n  resetToCheckpoint() {\n    this.offset = this.savedOffset;\n  }\n\n}\n\nexport const TYPES = {\n  VARINT: 0,\n  FIXED64: 1,\n  LENDELIM: 2,\n  FIXED32: 5\n};\nexport function decodeProto(buffer) {\n  const reader = new BufferReader(buffer);\n  const parts = [];\n  reader.trySkipGrpcHeader();\n\n  try {\n    while (reader.leftBytes() > 0) {\n      reader.checkpoint();\n      const byteRange = [reader.offset];\n      const indexType = parseInt(reader.readVarInt().toString());\n      const type = indexType & 0b111;\n      const index = indexType >> 3;\n      let value;\n\n      if (type === TYPES.VARINT) {\n        value = reader.readVarInt().toString();\n      } else if (type === TYPES.LENDELIM) {\n        const length = parseInt(reader.readVarInt().toString());\n        value = reader.readBuffer(length);\n      } else if (type === TYPES.FIXED32) {\n        value = reader.readBuffer(4);\n      } else if (type === TYPES.FIXED64) {\n        value = reader.readBuffer(8);\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n\n      byteRange.push(reader.offset);\n      parts.push({\n        byteRange,\n        index,\n        type,\n        value\n      });\n    }\n  } catch (err) {\n    reader.resetToCheckpoint();\n  }\n\n  return {\n    parts,\n    leftOver: reader.readBuffer(reader.leftBytes())\n  };\n}\nexport function typeToString(type, subType) {\n  switch (type) {\n    case TYPES.VARINT:\n      return \"varint\";\n\n    case TYPES.LENDELIM:\n      return subType || \"len_delim\";\n\n    case TYPES.FIXED32:\n      return \"fixed32\";\n\n    case TYPES.FIXED64:\n      return \"fixed64\";\n\n    default:\n      return \"unknown\";\n  }\n}","map":{"version":3,"sources":["/Users/afganaskarli/PycharmProjects/buf/src/protobufDecoder.js"],"names":["decodeVarint","BufferReader","constructor","buffer","offset","readVarInt","result","length","value","readBuffer","checkByte","slice","trySkipGrpcHeader","backupOffset","leftBytes","readInt32BE","bytesAvailable","Error","checkpoint","savedOffset","resetToCheckpoint","TYPES","VARINT","FIXED64","LENDELIM","FIXED32","decodeProto","reader","parts","byteRange","indexType","parseInt","toString","type","index","push","err","leftOver","typeToString","subType"],"mappings":"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","sourcesContent":["import { decodeVarint } from \"./varintUtils\";\n\nclass BufferReader {\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.offset = 0;\n  }\n\n  readVarInt() {\n    const result = decodeVarint(this.buffer, this.offset);\n    this.offset += result.length;\n\n    return result.value;\n  }\n\n  readBuffer(length) {\n    this.checkByte(length);\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n\n    return result;\n  }\n\n  // gRPC has some additional header - remove it\n  trySkipGrpcHeader() {\n    const backupOffset = this.offset;\n\n    if (this.buffer[this.offset] === 0 && this.leftBytes() >= 5) {\n      this.offset++;\n      const length = this.buffer.readInt32BE(this.offset);\n      this.offset += 4;\n\n      if (length > this.leftBytes()) {\n        // Something is wrong, revert\n        this.offset = backupOffset;\n      }\n    }\n  }\n\n  leftBytes() {\n    return this.buffer.length - this.offset;\n  }\n\n  checkByte(length) {\n    const bytesAvailable = this.leftBytes();\n    if (length > bytesAvailable) {\n      throw new Error(\n        \"Not enough bytes left. Requested: \" +\n          length +\n          \" left: \" +\n          bytesAvailable\n      );\n    }\n  }\n\n  checkpoint() {\n    this.savedOffset = this.offset;\n  }\n\n  resetToCheckpoint() {\n    this.offset = this.savedOffset;\n  }\n}\n\nexport const TYPES = {\n  VARINT: 0,\n  FIXED64: 1,\n  LENDELIM: 2,\n  FIXED32: 5\n};\n\nexport function decodeProto(buffer) {\n  const reader = new BufferReader(buffer);\n  const parts = [];\n\n  reader.trySkipGrpcHeader();\n\n  try {\n    while (reader.leftBytes() > 0) {\n      reader.checkpoint();\n\n      const byteRange = [reader.offset];\n      const indexType = parseInt(reader.readVarInt().toString());\n      const type = indexType & 0b111;\n      const index = indexType >> 3;\n\n      let value;\n      if (type === TYPES.VARINT) {\n        value = reader.readVarInt().toString();\n      } else if (type === TYPES.LENDELIM) {\n        const length = parseInt(reader.readVarInt().toString());\n        value = reader.readBuffer(length);\n      } else if (type === TYPES.FIXED32) {\n        value = reader.readBuffer(4);\n      } else if (type === TYPES.FIXED64) {\n        value = reader.readBuffer(8);\n      } else {\n        throw new Error(\"Unknown type: \" + type);\n      }\n      byteRange.push(reader.offset);\n\n      parts.push({\n        byteRange,\n        index,\n        type,\n        value\n      });\n    }\n  } catch (err) {\n    reader.resetToCheckpoint();\n  }\n\n  return {\n    parts,\n    leftOver: reader.readBuffer(reader.leftBytes())\n  };\n}\n\nexport function typeToString(type, subType) {\n  switch (type) {\n    case TYPES.VARINT:\n      return \"varint\";\n    case TYPES.LENDELIM:\n      return subType || \"len_delim\";\n    case TYPES.FIXED32:\n      return \"fixed32\";\n    case TYPES.FIXED64:\n      return \"fixed64\";\n    default:\n      return \"unknown\";\n  }\n}\n"]},"metadata":{},"sourceType":"module"}