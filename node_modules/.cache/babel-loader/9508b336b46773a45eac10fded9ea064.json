{"ast":null,"code":"import JSBI from \"jsbi\";\nimport { bufferLeToBeHex, bufferToPrettyHex } from \"./hexUtils\";\nimport { interpretAsSignedType } from \"./varintUtils\";\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n  const result = [];\n  result.push({\n    type: \"Int\",\n    value: intValue\n  });\n\n  if (intValue !== uintValue) {\n    result.push({\n      type: \"Unsigned Int\",\n      value: uintValue\n    });\n  }\n\n  result.push({\n    type: \"Float\",\n    value: floatValue\n  });\n  return result;\n}\nexport function decodeFixed64(value) {\n  const floatValue = value.readDoubleLE(0);\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n  const result = [];\n  result.push({\n    type: \"Int\",\n    value: intValue.toString()\n  });\n  return result;\n}\nexport function decodeStringOrBytes(value) {\n  if (!value.length) {\n    return {\n      type: \"string|bytes\",\n      value: \"\"\n    };\n  }\n\n  const td = new TextDecoder(\"utf-8\", {\n    fatal: true\n  });\n\n  try {\n    return {\n      type: \"string\",\n      value: td.decode(value)\n    };\n  } catch (e) {\n    return {\n      type: \"bytes\",\n      value: bufferToPrettyHex(value)\n    };\n  }\n}\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}","map":{"version":3,"sources":["/Users/afganaskarli/PycharmProjects/buf/src/protobufPartDecoder.js"],"names":["JSBI","bufferLeToBeHex","bufferToPrettyHex","interpretAsSignedType","decodeFixed32","value","floatValue","readFloatLE","intValue","readInt32LE","uintValue","readUInt32LE","result","push","type","decodeFixed64","readDoubleLE","BigInt","twoComplements","toString","decodeStringOrBytes","length","td","TextDecoder","fatal","decode","e","maxLong","longForComplement","greaterThan","subtract"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,MAAjB;AACA,SAASC,eAAT,EAA0BC,iBAA1B,QAAmD,YAAnD;AACA,SAASC,qBAAT,QAAsC,eAAtC;AAEA,OAAO,SAASC,aAAT,CAAuBC,KAAvB,EAA8B;AACnC,QAAMC,UAAU,GAAGD,KAAK,CAACE,WAAN,CAAkB,CAAlB,CAAnB;AACA,QAAMC,QAAQ,GAAGH,KAAK,CAACI,WAAN,CAAkB,CAAlB,CAAjB;AACA,QAAMC,SAAS,GAAGL,KAAK,CAACM,YAAN,CAAmB,CAAnB,CAAlB;AAEA,QAAMC,MAAM,GAAG,EAAf;AAEAA,EAAAA,MAAM,CAACC,IAAP,CAAY;AAAEC,IAAAA,IAAI,EAAE,KAAR;AAAeT,IAAAA,KAAK,EAAEG;AAAtB,GAAZ;;AAEA,MAAIA,QAAQ,KAAKE,SAAjB,EAA4B;AAC1BE,IAAAA,MAAM,CAACC,IAAP,CAAY;AAAEC,MAAAA,IAAI,EAAE,cAAR;AAAwBT,MAAAA,KAAK,EAAEK;AAA/B,KAAZ;AACD;;AAEDE,EAAAA,MAAM,CAACC,IAAP,CAAY;AAAEC,IAAAA,IAAI,EAAE,OAAR;AAAiBT,IAAAA,KAAK,EAAEC;AAAxB,GAAZ;AAEA,SAAOM,MAAP;AACD;AAED,OAAO,SAASG,aAAT,CAAuBV,KAAvB,EAA8B;AACnC,QAAMC,UAAU,GAAGD,KAAK,CAACW,YAAN,CAAmB,CAAnB,CAAnB;AACA,QAAMN,SAAS,GAAGV,IAAI,CAACiB,MAAL,CAAY,OAAOhB,eAAe,CAACI,KAAD,CAAlC,CAAlB;AACA,QAAMG,QAAQ,GAAGU,cAAc,CAACR,SAAD,CAA/B;AAEA,QAAME,MAAM,GAAG,EAAf;AAEAA,EAAAA,MAAM,CAACC,IAAP,CAAY;AAAEC,IAAAA,IAAI,EAAE,KAAR;AAAeT,IAAAA,KAAK,EAAEG,QAAQ,CAACW,QAAT;AAAtB,GAAZ;AAGA,SAAOP,MAAP;AACD;AAID,OAAO,SAASQ,mBAAT,CAA6Bf,KAA7B,EAAoC;AACzC,MAAI,CAACA,KAAK,CAACgB,MAAX,EAAmB;AACjB,WAAO;AAAEP,MAAAA,IAAI,EAAE,cAAR;AAAwBT,MAAAA,KAAK,EAAE;AAA/B,KAAP;AACD;;AACD,QAAMiB,EAAE,GAAG,IAAIC,WAAJ,CAAgB,OAAhB,EAAyB;AAAEC,IAAAA,KAAK,EAAE;AAAT,GAAzB,CAAX;;AACA,MAAI;AACF,WAAO;AAAEV,MAAAA,IAAI,EAAE,QAAR;AAAkBT,MAAAA,KAAK,EAAEiB,EAAE,CAACG,MAAH,CAAUpB,KAAV;AAAzB,KAAP;AACD,GAFD,CAEE,OAAOqB,CAAP,EAAU;AACV,WAAO;AAAEZ,MAAAA,IAAI,EAAE,OAAR;AAAiBT,MAAAA,KAAK,EAAEH,iBAAiB,CAACG,KAAD;AAAzC,KAAP;AACD;AACF;AAED,MAAMsB,OAAO,GAAG3B,IAAI,CAACiB,MAAL,CAAY,oBAAZ,CAAhB;AACA,MAAMW,iBAAiB,GAAG5B,IAAI,CAACiB,MAAL,CAAY,qBAAZ,CAA1B;;AAEA,SAASC,cAAT,CAAwBR,SAAxB,EAAmC;AACjC,MAAIV,IAAI,CAAC6B,WAAL,CAAiBnB,SAAjB,EAA4BiB,OAA5B,CAAJ,EAA0C;AACxC,WAAO3B,IAAI,CAAC8B,QAAL,CAAcpB,SAAd,EAAyBkB,iBAAzB,CAAP;AACD,GAFD,MAEO;AACL,WAAOlB,SAAP;AACD;AACF","sourcesContent":["import JSBI from \"jsbi\";\nimport { bufferLeToBeHex, bufferToPrettyHex } from \"./hexUtils\";\nimport { interpretAsSignedType } from \"./varintUtils\";\n\nexport function decodeFixed32(value) {\n  const floatValue = value.readFloatLE(0);\n  const intValue = value.readInt32LE(0);\n  const uintValue = value.readUInt32LE(0);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue });\n\n  if (intValue !== uintValue) {\n    result.push({ type: \"Unsigned Int\", value: uintValue });\n  }\n\n  result.push({ type: \"Float\", value: floatValue });\n\n  return result;\n}\n\nexport function decodeFixed64(value) {\n  const floatValue = value.readDoubleLE(0);\n  const uintValue = JSBI.BigInt(\"0x\" + bufferLeToBeHex(value));\n  const intValue = twoComplements(uintValue);\n\n  const result = [];\n\n  result.push({ type: \"Int\", value: intValue.toString() });\n\n\n  return result;\n}\n\n\n\nexport function decodeStringOrBytes(value) {\n  if (!value.length) {\n    return { type: \"string|bytes\", value: \"\" };\n  }\n  const td = new TextDecoder(\"utf-8\", { fatal: true });\n  try {\n    return { type: \"string\", value: td.decode(value) };\n  } catch (e) {\n    return { type: \"bytes\", value: bufferToPrettyHex(value) };\n  }\n}\n\nconst maxLong = JSBI.BigInt(\"0x7fffffffffffffff\");\nconst longForComplement = JSBI.BigInt(\"0x10000000000000000\");\n\nfunction twoComplements(uintValue) {\n  if (JSBI.greaterThan(uintValue, maxLong)) {\n    return JSBI.subtract(uintValue, longForComplement);\n  } else {\n    return uintValue;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}